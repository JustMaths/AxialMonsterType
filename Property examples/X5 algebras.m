AttachSpec("../2-gen Monster.spec");
AttachSpec("../../AxialTools/AxialTools.spec");

QQ := Rationals();
/*
******************************

X(5) axet

******************************
*/
// =========================================================
//
// 5A(al, (5al-1)/8)
//
// =========================================================

A, gen, frob := M5A();
F<al> := BaseRing(A);

// Check general properties
so, id := HasOne(A);
assert so;
assert id eq 8/(5*(3*al+1))*A![1,1,1,1,1,0];
// al can't be -1/3 as then al = bt
// So the algebra always has an identity if the characteristic is not 5

// No subalgebras to check

// Now check for ideals

assert frob[1,2] eq 3/2^5*(5*al - 1);
// So the projection graph always has an edge between a_0 and a_1 since al neq 1/5

assert Determinant(frob) eq -5^6/2^36*(3*al - 7)^5 * (5*al - 1) * (3*al + 1)^2;

// Since the characteristic can't be 2 and al can't be 1/5 or -1/3 (distinct eigenvalues)
// the only possibilities are if the characteristic is 5, or al = 7/3

//Case 1: char not 5 and al = 7/3
//case 2: a) Char 5
//        b) char 5 and al = 7/3
// For al = 7/3
A, gen, frob := M5A(7/3);

// The radical is 5-dimensional
assert Dimension(NullSpace(frob)) eq 5;

R := ideal<A| [A!x : x in Basis(Nullspace(frob))]>;

u1 := A.1+3/5*A.6;
u2 := A.2+3/5*A.6;
u3 := A.3+3/5*A.6;
u4 := A.4+3/5*A.6;
u5 := A.5+3/5*A.6;
assert u1 in R and u2 in R and u3 in R and u4 in R and u5 in R;

// In ordinary representation theory, R has G-module structure 1+4, so just need to check the trivial submodule and the irreducible module generated by the difference of axes

assert Dimension(ideal<A | u1+u2+u3+u4+u5>) eq 5;
assert Dimension(ideal<A | u1-u2>) eq 5;

// So no subideals of R

// Check characteristic 5
A, gen, frob := M5A(:base_ring:=GF(5));
F<al> := BaseRing(A);

// Now the algebra has no identity
assert not HasOne(A);

// The radical is 5-dimensional
assert Dimension(NullSpace(frob)) eq 5;

R := ideal<A| [A!x : x in Basis(Nullspace(frob))]>;

assert A.6 in R;
assert forall{i : i in [2..5] | A.1-A.5 in R};

// Since the characteristic is 5, the G-module structure is more complicated
// A.6 spans a trivial module
// The differences of axes is an indecomposible module, but not irreducible as the sum of axes is an irreducible submodule.

ann := Annihilator(A);
assert Dimension(ann) eq 1;
assert A.1+A.2+A.3+A.4+A.5 in ann;

// Check the submodule structure
t1 := MiyamotoInvolution(A.1);
t2 := MiyamotoInvolution(A.2);

G := sub<GL(6,5)|t1,t2>; // Can check over GF(5), not GF(5)[al]
M := GModule(G);
N := sub<M|M.1-M.2>;
SN := Submodules(N);

// There is one submodule of each dimension
assert #SN eq 5;
assert [Dimension(U) : U in SN] eq [0..4];

n1 := M.1-M.2;
n2 := M.2-M.3;
n3 := M.3-M.4;
n4 := M.4-M.5;

assert Dimension(sub<M | n1,n2,n3,n4>) eq 4;

// contains all the differences of N = N4
N3 := sub<M| n1-n2>;
assert Dimension(N3) eq 3;

// contains all the differences of N3
// this is generated by (n1-n2) -(n2-n3) = n1 - 2*n2 + n3
N2 := sub<M| (n1-n2) -(n2-n3) >;
assert Dimension(N2) eq 2;

// contains all the differences of N2
// this is n1 - 2*n2 + n3 - (n2 - 2*n3 + n4) = n1 -3*n2 +3*n3 -n4
// This is the sum of all the axes
N1 := sub<M| n1+2*n2 +3*n3 -n4>;
assert Dimension(N1) eq 1;

// Now look at the ideals
U1 := ideal<A|[A!Eltseq(M!v):v in Basis(N1)]>;
assert Dimension(U2) eq 2;

// Q1 is a new 2-generated Monster type algebra
Q1, phi1 := quo<A|U1>;
assert HasMonsterFusionLaw(A.1@phi1: fusion_values:=[al,GF(5)!3]);
assert #Eigenvalues(A.1@phi1) eq 4;
assert sub<Q1 | A.1@phi1, A.2@phi1> eq Q1;
assert #{A.i@phi1 : i in [1..5]} eq 5;
// It has Dimension 5 and axial dimension 4
assert Dimension(sub<VectorSpace(Q1)| [ Vector(A.i@phi1) : i in [1..5]]>) eq 4;

U2 := ideal<A|[A!Eltseq(M!v):v in Basis(N2)]>;
assert Dimension(U2) eq 2;

// Q2 is a new 2-generated Monster type algebra
Q2, phi2 := quo<A|U2>;
assert HasMonsterFusionLaw(A.1@phi2: fusion_values:=[al,GF(5)!3]);
assert #Eigenvalues(A.1@phi2) eq 4;
assert sub<Q2 | A.1@phi2, A.2@phi2> eq Q2;
assert #{A.i@phi2 : i in [1..5]} eq 5;
// It has Dimension 4 and axial dimension 3
assert Dimension(sub<VectorSpace(Q2)| [ Vector(A.i@phi2) : i in [1..5]]>) eq 3;

U3 := ideal<A|[A!Eltseq(M!v):v in Basis(N3)]>;
assert Dimension(U3) eq 4;

// Q3 is the Jordan type 1/2 algebra \widehat{S(2)}^circ
Q3, phi3 := quo<A|U3>;
assert HasJordanFusionLaw(A.1@phi3: fusion_value:=GF(5)!(1/2));
assert #{A.i@phi3 : i in [1..5]} eq 5;
assert GF(5)!3 eq GF(5)!(1/2);
assert #Eigenvalues(A.1@phi3) eq 2;
assert sub<Q3 | A.1@phi3, A.2@phi3> eq Q3;
assert not HasOne(Q3);


//U4 is the same as the radical
U4 := ideal<A|[A!Eltseq(M!v):v in Basis(N)]>;
assert Dimension(U4) eq 5;
// So quotient here is just 1A



// Need to check for when the characteristic is 5 and al = 7/3
A, gen, frob := M5A(GF(5)!7/3);
F := BaseRing(A);


I := ideal<A|A.6>;
assert Dimension(I) eq 6;


T := ideal<A|A.1+A.2+A.3+A.4+A.5>;
assert Dimension(T) eq 1;

t1 := MiyamotoInvolution(A.1);
t2 := MiyamotoInvolution(A.2);

F := BaseRing(A);
G := sub<GL(6,F)|t1,t2>;
M := GModule(G);
N := sub<M|M.1-M.2>;
SN := Submodules(N);

t := A.1+A.2+A.3+A.4+A.5;
z := A.6;

// t is the annihilator

assert [t*A.i: i in [1..6]] eq [0,0,0,0,0,0];


// /////////////////////////

U2 := ideal<A|[A!Eltseq(M!v):v in Basis(SN[3])]>;
assert Dimension(U2) eq 2;

U3 := ideal<A|[A!Eltseq(M!v):v in Basis(SN[4])]>;
assert Dimension(U3) eq 4;

U4 := ideal<A|[A!Eltseq(M!v):v in Basis(N)]>;
assert Dimension(U4) eq 5;
//U4 is the same as the radical

// [A!v: v in Basis(U3)];

QT, quo := quo<A|T>;
assert Dimesion(QT) eq 5;

//  IdentifyFusionLaw(QT.1: eigenvalues:= [1,0,4,3]); Has monster fusion law
// Is equal to 5A(-1,1/2)^x ????????
// This lead to the theorem IY5 isomorphic to M5A in char = 5

QU3, quo := quo<A|U3>;
assert Dimesion(QT) eq 2;

//  IdentifyFusionLaw(QU3.1); Has jordan fusion law with eigen values 1, 1/2
// Is equal to S(2)^\circ ????????


// study this exapmle more





//------------------------------------------
//
// Idempotents
//
//------------------------------------------
load "Find idempotents.m";

A, gen, frob := M5A();
F<al> := BaseRing(A);
bt := (5*al-1)/8;

t1 := MiyamotoInvolution(A.1);
t2 := MiyamotoInvolution(A.2);

phi := Matrix(F,[[ 1,0,0,0,0,0],
               [ 0,0,1,0,0,0],
               [ 0,0,0,0,1,0],
               [ 0,1,0,0,0,0],
               [ 0,0,0,1,0,0],
               [ -bt/2,-bt/2,-bt/2,-bt/2,-bt/2,-1]]);


// phi is an automorphism
assert forall{ <i,j> : i,j in [1..6] | (A.i*phi)*(A.j*phi) eq (A.i*A.j)*phi};
Miy := sub<GL(6,F) | t1,t2>;
G := sub<GL(6,F) | t1,t2,phi>;

// Needed to ensure Magma knows the order of the group over FCl and so to be able to take orbits
assert Order(Miy) eq 10;
assert Order(G) eq 20;

I := IdempotentIdeal(A);

// Takes about 120 secs
prim := PrimaryDecomposition(I);

FCl := AlgebraicClosure(F);
// Need to add roots
// bt = (5*al-1)/8;
f := (al^3-6*al^2+1);
rt1 := Sqrt(-FCl!(5*(5*al-1)*(3*al-7)));
rt2 := Sqrt(FCl!5*al);
rt3 := Sqrt(FCl!(2*al-1));
rt4 := Sqrt(-FCl!(5*al-1)*f);

ACl := ChangeRing(A, FCl);
frobCl := ChangeRing(frob, FCl);

vars := [ Variety(J, FCl) : J in prim];

idems := &cat[ [ ACl![ t[i] : i in [1..6]] : t in var] : var in vars];

// Simplify takes a long time, but partial is quick
Simplify(FCl:Partial:=true);
Prune(FCl);

if Rank(FCl) eq 5 then
  // Magma has added a new root, but it is a combination of old ones
  assert FCl.5 eq -2^4*rt3/rt2/rt4; // or maybe this: or FCl.5 eq 2^4*rt3/rt2/rt4;
end if;

G_FCl := ChangeRing(G, FCl);
orbs := {@ {@ ACl!u : u in Orbit(G_FCl, Vector(v))@} : v in idems @};
Sort(~orbs, func<x,y|#x-#y>); // sort smallest first

assert #orbs eq 10;
assert [#o : o in orbs] eq [ 1, 1, 2, 5, 5, 10, 10, 10, 10, 10];

// zero and the identity are the two idempotents in an orbit of size one.
so, id := HasOne(ACl);
assert so;
assert id eq 8/(5*(3*al+1))*ACl![1,1,1,1,1,0];

v1 := 1/(3*al+1)*( (4/5*rt1/(3*al-7) + 4/5)*(ACl.1+ACl.2+ACl.3+ACl.4+ACl.5) +2^7/5*rt1/(3*al-7)/(5*al-1)*ACl.6);
assert v1 in orbs[3];
assert id - v1 in orbs[3];

// for the orbits of size 5 we have the axes and id - axes
assert {@ ACl.i : i in [1..5] @} in orbs;
assert {@ id - ACl.i : i in [1..5] @} in orbs;


// One of the orbits of size 10
v2 := id/2
            +1/(3*al-7)/(3*al+1)*rt1 *(
                  1/5/al*( (al-1)*ACl.1 -2*(al+1)*(ACl.2 +ACl.5))
                   +4/5*(ACl.3+ACl.4) + 32/5*(al-1)/al/(5*al-1)*ACl.6
                                       ); 

assert exists(o2){ o : o in orbs | v2 in o};
assert id -v2 in o2;

// id-v2 is equal to the above but with the last big sum as a minus
phi_FCl := ChangeRing(phi, FCl);
assert (v2-id/2)*phi_FCl eq -(v2-id/2);
// So the extra automorphism is acting as a field automorphism exchanging rt1 for -rt1

// Two more orbits of size 10
v3 := id/2 +ACl.1/2
         + rt2/5/(3*al+1)*( 1/2*(5*al-1)/al*ACl.1 + (al-1)/al*(ACl.2+ACl.5)
                           +4*(ACl.3+ACl.4) + 16/al*ACl.6);
assert exists(o3){ o : o in orbs | v3 in o};
assert id -v3 notin o2;

assert exists(o3_pair){ o : o in orbs | id-v3 in o};

// The extra automorphism is acting as a field automorphism exchanging rt2 for -rt2
assert (v3 -id/2 -ACl.1/2)*phi_FCl eq -(v3 -id/2 -ACl.1/2);

// Final two orbits of size 10
v4 := id/2
         + rt4/5/f* ( (1/2/al*rt3*rt2 - 1/2*(7*al+5)/(3*al+1) )*ACl.1
                      +(1/al*rt3*rt2 + 4*al/(3*al+1) ) *(ACl.2+ACl.5)
                      +4*al/(3*al+1)*(ACl.3+ACl.4)
                      +16/al/(5*al-1)*rt2*rt3*ACl.6
                     );

assert exists(o4){ o : o in orbs | v4 in o};
assert id -v3 notin o4;

assert exists(o4_pair){ o : o in orbs | id-v4 in o};

// We already know that f_FCl inverts rt1 and rt2.  We see from below it fixes rt4 (look at the ACl.3+ACl.4 component, and so fixes rt3 (look at the other components).
assert (v4 -id/2)*phi_FCl - (v4-id/2) eq
        -2* rt4/5/f*( 1/2/al*rt3*rt2*ACl.1 + 1/al*rt3*rt2*(ACl.2+ACl.5)
                      +16/al/(5*al-1)*rt2*rt3*ACl.6);

// We have found all the remaining axes
assert #(o2 join o3 join o3_pair join o4 join o4_pair) eq 50;


//////////////////////////////////////////////////////
// Theorem: IY5 and M5A are isomorphic in characteristic 5

A, gen, frob := M5A(: base_ring := GF(5));

// Take out once got everything programmed properly
Attach("Yabe_algebras.m");

A2, gen2, frob2 := V2(: base_ring := GF(5));

// Checking the 6th basis vector

assert A.6 eq A.1*A.2 - 3*(A.1+A.2);
assert A2.6 eq A2.1*A2.2 - 3*(A2.1+A2.2);

// Checking if the multiplication is the same

multA := BasisProducts(A);
multA2 := BasisProducts(A2);

multA := [[Eltseq(v): v in R]: R in multA];
multA2 := [[Eltseq(v): v in R]: R in multA2];

assert multA eq multA2;
/////////////////////////////////////////////////////////



